#version 450

layout (local_size_x_id = 0) in;

layout(binding = 0, set = 0, rgba8) uniform image2D inTex;
layout(binding = 1, set = 0, rgba8) uniform image2D outTex;

layout (set = 0, binding = 2) uniform UBO 
{
	int numParticles;
	int init;
	float dt;
	float moveSpeed;
	float evaporateSpeed;
	float diffuseSpeed;
	float turnSpeed;
};

struct Particle
{
	vec2 pos;
	float angle;
};

layout(std140, set = 0, binding = 3) buffer SBO 
{
   Particle particles[ ];
};

uint hash(uint state) {
	state ^= 2747636419u;
	state *= 2654435769u;
	
	state ^= state >> 16;
	state *= 2654435769u;

	state ^= state >> 16;
	state *= 2654435769u;

	return state;
}

float map01(uint val) { return val / 4294968295.0; }

#define PI 3.1415926535897932384626433832795

int width = 512;
int height = 512;

float sense(Particle particle, float sensorAngleOffset) {
	int sensorSize = 1;
	float sensorAngle = particle.angle + sensorAngleOffset;
	vec2 sensorDir = vec2(cos(sensorAngle), sin(sensorAngle));
	ivec2 sensorCenter = ivec2(particle.pos + sensorDir * 35);
	float sum = 0.0;
	
	for(int offsetX = -sensorSize; offsetX <= sensorSize; ++offsetX) {
	for(int offsetY = -sensorSize; offsetY <= sensorSize; ++offsetY) {
		int sampleX = offsetX + sensorCenter.x;
		int sampleY = offsetY + sensorCenter.y;
		
		if(sampleX >= 0 && sampleX < width && sampleY >= 0 && sampleY < height) {
			sum += imageLoad(inTex, ivec2(sampleX, sampleY)).x;
		}
	}
	}
	
	return sum;
}

void main() 
{
	uint idx = gl_GlobalInvocationID.x * 512 + gl_GlobalInvocationID.y;
		
	uint random = hash(uint(particles[idx].pos.y) * width + uint(particles[idx].pos.x) + hash(idx));

	if(init == 1) {
		particles[idx].pos.x = sin(map01(random) * 2 * PI) * (width / 2) + height / 2;
		particles[idx].pos.y = cos(map01(random) * 2 * PI) * (height /2) + height / 2;
	} 
	
	float weightForward = sense(particles[idx], 0);
	float weightLeft = sense(particles[idx], PI / 2 * 30 / 360);
	float weightRight = sense(particles[idx], -PI / 2 * 30 / 360);
	
	float randomSteerStrength = map01(random);
	
	if(weightForward > weightLeft && weightForward > weightRight) {
		particles[idx].angle += 0.0;
	} else if (weightForward < weightLeft && weightForward < weightRight) {
		particles[idx].angle += (randomSteerStrength - 0.5) * 2 * turnSpeed * dt;
	} else if (weightRight > weightLeft) {
		particles[idx].angle -= randomSteerStrength * turnSpeed * dt;
	} 
	else if (weightLeft > weightRight) {
		particles[idx].angle += randomSteerStrength * turnSpeed * dt;
	}
	
	vec2 dir = vec2(cos(particles[idx].angle), sin(particles[idx].angle));
	vec2 pos = particles[idx].pos + dir * moveSpeed * dt;
	
	if (pos.x < 0 || pos.x >= width || pos.y < 0 || pos.y >= height) {
		random = hash(random);
		float randomAngle = map01(random) * 2 * PI;

		pos.x = min(width-1,max(0, pos.x));
		pos.y = min(height-1,max(0, pos.y));
		particles[idx].angle = randomAngle;
	}
	
	particles[idx].pos = pos;
	imageStore(outTex, ivec2(pos.x, pos.y), vec4(1.0));
}